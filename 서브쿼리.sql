--서브쿼리
--SELECT문이 SELECT구문으로 들어가는 형태 : 스칼라 서브쿼리
--SELECT문이 FROM구문으로 들어가는 형태 : 인라인 뷰
--SELECT문이 WHERE구문으로 들어가는 형태 : 서브쿼리

--단일행 서브쿼리 - 리턴되는 행이 1개인 서브쿼리
--Nancy보다 많은 급여를 받는 사원 출력
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES 
WHERE SALARY >= (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy')
ORDER BY SALARY DESC;

--EMPLOYEE_ID가 103번인 사람과 동일한 직군
SELECT JOB_ID, EMPLOYEE_ID
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 103);

--주의할 점, 단일행이어야 한다. 컬럼값도 1개이어야 함
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = (SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 103 OR EMPLOYEE_ID = 104); --ERROR

--------------------------------------------------------------------------------
--다중행 서브쿼리 - 행이 여러개라면 IN ANY ALL로 비교
SELECT SALARY
FROM EMPLOYEES
WHERE FIRST_NAME = 'David';

--IN 동일한 값을 찾음 IN(4800,6000,9500)
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY IN(SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

--ANY : 최솟값보다 큼 최댓값보다 작음
SELECT *
FROM EMPLOYEES
WHERE SALARY > ANY ( SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David'); --급여가 4800보다 큰 사람들

SELECT *
FROM EMPLOYEES
WHERE SALARY < ANY ( SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David'); --급여가 9500보다 작은 사람들

--ALL 최댓값보다 큼, 최솟값보다 작음
SELECT * 
FROM EMPLOYEES
WHERE SALARY < ALL ( SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David'); --급여가 4800보다 작은 사람들

SELECT *
FROM EMPLOYEES
WHERE SALARY > ALL ( SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David'); --급여가 9500보다 큰 사람들

--직업이 IT_PROG인 사람들의 급여 중 최솟값보다 큰 급여를 받는 사람들
SELECT *
FROM EMPLOYEES
WHERE SALARY > ANY ( SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG');

--------------------------------------------------------------------------------
--스칼라 서브쿼리
--JOIN 시에 특정 테이블의 1개의 컬럼을 가지고 올 때 유리함
SELECT FIRST_NAME,
       EMAIL,
      (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID)
FROM EMPLOYEES E
ORDER BY FIRST_NAME;
--위 아래 구문의 결과는 동일--
SELECT FIRST_NAME,
       EMAIL,
       DEPARTMENT_NAME
FROM EMPLOYEES E LEFT JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
ORDER BY FIRST_NAME;

--각 부서의 매니저 이름을 출력하고 싶다
--스칼라
SELECT D.*,
       (SELECT FIRST_NAME FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = D.MANAGER_ID) AS 매니저명
FROM DEPARTMENTS D;
--JOIN
SELECT D.*, E.FIRST_NAME AS 매니저명
FROM DEPARTMENTS D LEFT JOIN EMPLOYEES E ON D.MANAGER_ID = E.EMPLOYEE_ID;

--스칼라쿼리는 여러번 작성 가능
SELECT * FROM JOBS; --JOB_TITLE
SELECT * FROM DEPARTMENTS; --DEPARTMENT_NAME
SELECT * FROM EMPLOYEES; 

SELECT E.FIRST_NAME,
       E.JOB_ID,
       (SELECT JOB_TITLE FROM JOBS J WHERE J.JOB_ID = E.JOB_ID) AS JOB_TITLE,
       (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) AS DEPARTMENT_NAME
FROM EMPLOYEES E;

--각 부서의 사원 수를 출력 + 부서정보
SELECT DEPARTMENT_ID, COUNT(*)
FROM EMPLOYEES E
GROUP BY DEPARTMENT_ID;

SELECT D.*,
       NVL((SELECT COUNT(*) FROM EMPLOYEES E WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID GROUP BY DEPARTMENT_ID),0) AS 사원수
FROM DEPARTMENTS D;
--------------------------------------------------------------------------------
--인라인 뷰
--가짜 테이블 형태
SELECT ROWNUM, E.* FROM EMPLOYEES E ORDER BY FIRST_NAME;

--ROWNUM는 조회된 순서이기 때문에 ORDER와 같이 사용되면 ROWNUM이 섞이는 문제를 해결
SELECT ROWNUM,
       FIRST_NAME,
       SALARY
FROM (SELECT *
      FROM EMPLOYEES
      ORDER BY SALARY DESC);
      
--테이블 엘리어스 사용하기
SELECT ROWNUM,
       A.*
FROM (SELECT FIRST_NAME, 
             SALARY,
             FIRST_NAME ||' '||LAST_NAME AS NAME
      FROM EMPLOYEES
      ORDER BY SALARY
      ) A;

    
--ROWNUM은 무조건 1번부터 조회가 가능하기 때문에 중간번째 데이터는 추출불가
SELECT ROWNUM, FIRST_NAME, SALARY
FROM (SELECT * FROM EMPLOYEES ORDER BY SALARY DESC)
WHERE ROWNUM BETWEEN 1 AND 5;

SELECT ROWNUM,
       FIRST_NAME,
       SALARY
FROM (SELECT *
      FROM EMPLOYEES
      ORDER BY SALARY DESC)
WHERE ROWNUM BETWEEN 11 AND 20;


--2번째 인라인뷰에서 ROWNUM을 RN으로 컬럼화하면 ROWNUM의 중간번호도 추출가능
SELECT RN, FIRST_NAME, SALARY
FROM( SELECT ROWNUM AS RN,
             FIRST_NAME,
             SALARY
      FROM (SELECT *
            FROM EMPLOYEES
            ORDER BY SALARY DESC))
WHERE RN > 49 AND RN <= 60;

--인라인 뷰의 예시
SELECT TO_CHAR(REGDATE,'YY-MM-DD') AS REGDATE, NAME
FROM (SELECT 'CHARLIE' AS NAME, SYSDATE AS REGDATE FROM DUAL
      UNION ALL
      SELECT 'LOLA', SYSDATE FROM DUAL);

--인라인 뷰의 응용
--부서별 사원수
SELECT * FROM DEPARTMENTS;

SELECT D.*, E.TOTAL
FROM DEPARTMENTS D 
LEFT JOIN (SELECT DEPARTMENT_ID, COUNT(*) AS TOTAL FROM EMPLOYEES GROUP BY DEPARTMENT_ID) E 
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID;

--정리
--단일행(대소비교) VS 다중행 서브쿼리(IN, ANY, ALL)
--스칼라쿼리 - LEFT JOIN과 같은 역할. 한번에 1개의 컬럼을 가져올 때
--인라인뷰 - FROM절에 들어가는 가짜 테이블
